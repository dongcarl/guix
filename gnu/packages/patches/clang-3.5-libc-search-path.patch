Clang attempts to guess file names based on the OS and distro (yes!),
but unfortunately, that doesn't work for us.

This patch makes it easy to insert libc's $libdir so that Clang passes the
correct absolute file name of crt1.o etc. to 'ld'.  It also disables all
the distro-specific stuff and removes the hard-coded FHS directory names
to make sure Clang also works on non-GuixSD systems.

--- cfe-3.6.0.src/lib/Driver/ToolChains.cpp	2015-02-18 22:03:07.000000000 +0100
+++ cfe-3.6.0.src/lib/Driver/ToolChains.cpp	2015-06-19 16:37:20.459701044 +0200
@@ -3040,6 +3040,9 @@
 
   Linker = GetLinkerPath();
 
+  // Comment out the distro-specific tweaks so that they don't bite when
+  // using Guix on a foreign distro.
+#if 0
   Distro Distro = DetectDistro(Arch);
 
   if (IsOpenSUSE(Distro) || IsUbuntu(Distro)) {
@@ -3082,6 +3085,7 @@
 
   if (IsOpenSUSE(Distro))
     ExtraOpts.push_back("--enable-new-dtags");
+#endif
 
   // The selection of paths to try here is designed to match the patterns which
   // the GCC driver itself uses, as this is part of the GCC-compatible driver.
@@ -3194,6 +3198,10 @@
 
   addPathIfExists(SysRoot + "/lib", Paths);
   addPathIfExists(SysRoot + "/usr/lib", Paths);
+
+  // Add libc's lib/ directory to the search path, so that crt1.o, crti.o,
+  // and friends can be found.
+  addPathIfExists("@GLIBC_LIBDIR@", Paths);
 }
 
 bool Linux::HasNativeLLVMSupport() const {
@@ -3384,6 +3392,34 @@
   addExternCSystemInclude(DriverArgs, CC1Args, SysRoot + "/include");
 
   addExternCSystemInclude(DriverArgs, CC1Args, SysRoot + "/usr/include");
+
+  // Check for configure-time "extra" C include directories. When constructing a
+  // toolchain, @C_EXTRA_INCLUDE_DIRS@ should be replaced with something like a
+  // colon-separated string of the include dirs of libc and kernel headers.
+  //
+  // The reason why we use this mechanism instead of C_INCLUDE_DIRS above is
+  // because when a user supplies clang with --sysroot, the normal expectation
+  // is that clang will detect and add the proper $SYSROOT/$MULTIARCHINCL,
+  // $SYSROOT/include, and $SYSROOT/usr/include to its list of search paths.
+  // However, if C_INCLUDE_DIRS is not empty, this function will return early
+  // and not attempt to add the aforementioned search paths, which is not
+  // desirable.
+  //
+  // By adding our configure-time "extra" C include directories here, after
+  // we've added $SYSROOT/include and $SYSROOT/usr/include, we make sure that IF
+  // --sysroot is supplied on the command line, we pick up the expected search
+  // paths in the $SYSROOT, and that they come before our configure-time "extra"
+  // C include directories.
+  StringRef CExtraIncludeDirs("@C_EXTRA_INCLUDE_DIRS@");
+  if (CExtraIncludeDirs != "") {
+      SmallVector<StringRef, 5> dirs;
+      CExtraIncludeDirs.split(dirs, ":");
+      for (StringRef dir : dirs) {
+          StringRef Prefix =
+              llvm::sys::path::is_absolute(dir) ? StringRef(SysRoot) : "";
+          addExternCSystemInclude(DriverArgs, CC1Args, Prefix + dir);
+      }
+  }
 }
 
 /// \brief Helper to add the variant paths of a libstdc++ installation.
