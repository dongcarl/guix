Clang attempts to guess file names based on the OS and distro (yes!),
but unfortunately, that doesn't work for us.

This patch makes it easy to insert libc's $libdir so that Clang passes the
correct absolute file name of crt1.o etc. to 'ld'.  It also disables all
the distro-specific stuff and removes the hard-coded FHS directory names
to make sure Clang also works on non-GuixSD systems.

--- a/lib/Driver/ToolChains/Linux.cpp
+++ b/lib/Driver/ToolChains/Linux.cpp
@@ -225,7 +225,9 @@
   PPaths.push_back(Twine(GCCInstallation.getParentLibPath() + "/../" +
                          GCCInstallation.getTriple().str() + "/bin")
                        .str());
-
+  // Comment out the distro-specific tweaks so that they don't bite when
+  // using Guix on a foreign distro.
+#if 0
   Distro Distro(D.getVFS());
 
   if (Distro.IsAlpineLinux()) {
@@ -284,6 +286,7 @@
 
   if (IsAndroid || Distro.IsOpenSUSE())
     ExtraOpts.push_back("--enable-new-dtags");
+#endif
 
   // The selection of paths to try here is designed to match the patterns which
   // the GCC driver itself uses, as this is part of the GCC-compatible driver.
@@ -431,6 +434,10 @@
 
   addPathIfExists(D, SysRoot + "/lib", Paths);
   addPathIfExists(D, SysRoot + "/usr/lib", Paths);
+
+  // Add libc's lib/ directory to the search path, so that crt1.o, crti.o,
+  // and friends can be found.
+  addPathIfExists(D, "@GLIBC_LIBDIR@", Paths);
 }
 
 bool Linux::HasNativeLLVMSupport() const { return true; }
@@ -794,6 +801,34 @@
   addExternCSystemInclude(DriverArgs, CC1Args, SysRoot + "/include");
 
   addExternCSystemInclude(DriverArgs, CC1Args, SysRoot + "/usr/include");
+
+  // Check for configure-time "extra" C include directories. When constructing a
+  // toolchain, @C_EXTRA_INCLUDE_DIRS@ should be replaced with something like a
+  // colon-separated string of the include dirs of libc and kernel headers.
+  //
+  // The reason why we use this mechanism instead of C_INCLUDE_DIRS above is
+  // because when a user supplies clang with --sysroot, the normal expectation
+  // is that clang will detect and add the proper $SYSROOT/$MULTIARCHINCL,
+  // $SYSROOT/include, and $SYSROOT/usr/include to its list of search paths.
+  // However, if C_INCLUDE_DIRS is not empty, this function will return early
+  // and not attempt to add the aforementioned search paths, which is not
+  // desirable.
+  //
+  // By adding our configure-time "extra" C include directories here, after
+  // we've added $SYSROOT/include and $SYSROOT/usr/include, we make sure that IF
+  // --sysroot is supplied on the command line, we pick up the expected search
+  // paths in the $SYSROOT, and that they come before our configure-time "extra"
+  // C include directories.
+  StringRef CExtraIncludeDirs("@C_EXTRA_INCLUDE_DIRS@");
+  if (CExtraIncludeDirs != "") {
+      SmallVector<StringRef, 5> dirs;
+      CExtraIncludeDirs.split(dirs, ":");
+      for (StringRef dir : dirs) {
+          StringRef Prefix =
+              llvm::sys::path::is_absolute(dir) ? StringRef(SysRoot) : "";
+          addExternCSystemInclude(DriverArgs, CC1Args, Prefix + dir);
+      }
+  }
 }
 
 static std::string DetectLibcxxIncludePath(StringRef base) {
